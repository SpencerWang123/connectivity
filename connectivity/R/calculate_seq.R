#' calculate_seq
#' @description
#' function to generate node seq and the corresponding connectivity seq on the given network according to a given seq
#'
#' @param adjmat adjacency matrix of a network which should have identical colnames and rownames
#' @param tuning_in weight of the in-connect when evaluating the connectivity. float in [0,1]
#' @param tuning_out weight of the out-connect when evaluating the connectivity. float in [0,1]
#' @param alpha smooth parameter which reflects how much the connectivity rely on the temp result. float in [0,1]
#' @param seed random seed used to initialize the first node in Node seq
#' @param memory memory length, which decides how many recent nodes are taken into consideration when calculating the connectivity. int
#' @param given_seq given seq generated by other criterion
#' @param jump possibility of choosing a random node regardless of the connectivity when generating a new node in node seq. float in [0,1]
#' @param length_seq length of the connectivity seq and node seq
#'
#' @return a list contenting node seq and connectivity seq
#' @export
#'
calculate_seq=function(adj_mat,tuning_in=0.5,tuning_out=0.5,alpha=1,seeds=10,memory,given_seq)#
{
  set.seed(seeds)
  length_seq=length(given_seq)
  N=ncol(adj_mat);out_degree=apply(adj_mat,1,sum);in_degree=apply(adj_mat,2,sum)
  #空表
  connect_record=0;
  temp_smooth=0;connect_record_smooth=0
  connect_maximun_point=0
  connect_record_memory=0;
  expect_connect=0
  temp_node_list=NULL
  #孤立点问题
  isolated_node=which(out_degree+in_degree==0);
  occupied_node=c(isolated_node)
  #初始化点
  temp_node=given_seq[1];

  #循环开始生成社群
  for (i in 1:(length_seq-1))
  {
    target_node=given_seq[i+1]
    #出度比例
    memory_out_degree=matrix(adj_mat[,colnames(adj_mat)%in%tail(temp_node,memory)],nrow = N)
    temp_connect_out_ratio=apply(memory_out_degree,1,sum)/(out_degree+1)
    out_connect=temp_connect_out_ratio[target_node]
    #入度比例
    memory_in_degree=matrix(t(adj_mat[rownames(adj_mat)%in%tail(temp_node,memory),]),nrow = N)
    temp_connect_in_ratio=apply(memory_in_degree,1 ,sum )/(in_degree+1)
    in_connect=temp_connect_in_ratio[target_node]
    #汇总
    temp_connect=(tuning_in*in_connect+tuning_out*out_connect)
    max_connect=temp_connect
    #从这里设置jump的步骤-截断temp_node，塑造新的temp_node
    high_rank=target_node
    temp_smooth=(1-alpha)*temp_smooth+alpha*max_connect
    #根据记忆，记录最大连接度节点
    temp_node=c(temp_node,high_rank);
    #记录连接度（原始和未平滑）
    connect_record_smooth=c(connect_record_smooth,temp_smooth)
  }
  temp_node_list=c(temp_node_list,temp_node)
  node_seq_all=unlist(temp_node_list)
  results=c(list(node_seq_all),list(connect_record_smooth))
  names(results)=c("node_seq","connect_record_smooth")
  return(results)
}

